<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Holographic String Engine</title>
    <!-- Chosen Palette: Warm Neutral Harmony -->
    <!-- Application Structure Plan: The SPA is structured as an interactive workbench. The user flow is linear: 1) Input a string (the "waveform"). 2) Click "Analyze" to see the results. 3) Explore the output. The layout uses a two-column design to present the visualization and the data blueprint side-by-side. This allows for direct, interactive comparison between the raw string and its deconstructed components (Key and Remnant). A final section explains the mechanism. This structure was chosen to transform the abstract report into a hands-on tool, prioritizing learning-by-doing over passive reading. -->
    <!-- Visualization & Content Choices: 
        - Report Info: The core algorithm (scanning, selection, generation). Goal: Demonstrate the algorithm in action. Viz/Presentation: An HTML Canvas visualization shows the original string, with characters colored according to the resonance they belong to. The Resonance Key is an interactive list. The Remnant Stream is a text block. Interaction: Hovering over a key entry highlights the corresponding characters on the canvas. Justification: This direct visual feedback makes the abstract concept of "claiming" characters tangible. Library/Method: Vanilla JS for logic, HTML Canvas for visualization, Tailwind for layout.
        - Report Info: Performance metrics. Goal: Quantify the algorithm's effectiveness. Viz/Presentation: Dynamic stat cards for Original Length, Encoded Length, and Reduction. Interaction: These update instantly on analysis. Justification: Provides immediate, clear feedback on the outcome. Library/Method: HTML/CSS.
        - Report Info: The mechanism steps. Goal: Explain how it works. Viz/Presentation: A three-part infographic-style layout using HTML/CSS. Interaction: Static display. Justification: Reinforces the concepts from the report within the context of the tool. Library/Method: HTML/CSS with Tailwind. -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8f7f2; /* Warm Neutral Background */
            color: #4c4a44; /* Dark Neutral Text */
        }
        .mono {
            font-family: 'Roboto Mono', monospace;
        }
        .key-entry:hover {
            background-color: #e9e7e0; /* Lighter Neutral Hover */
            cursor: pointer;
        }
        .chart-container {
            position: relative;
            width: 100%;
            height: 300px;
            max-height: 40vh;
        }
        @media (min-width: 768px) {
            .chart-container {
                height: 400px;
            }
        }
    </style>
</head>
<body class="p-4 sm:p-6 lg:p-8">
    <div class="max-w-7xl mx-auto">
        <header class="text-center mb-10">
            <h1 class="text-3xl sm:text-4xl lg:text-5xl font-bold text-slate-800">Holographic String Engine</h1>
            <p class="mt-2 text-lg text-slate-500">An interactive structural analysis of string resonance.</p>
        </header>

        <!-- Main Interactive Workbench -->
        <main class="bg-white rounded-lg shadow-sm border border-slate-200 p-4 sm:p-6 lg:p-8">
            <div class="mb-8">
                <h2 class="text-2xl font-bold text-slate-700 mb-2">1. Input Waveform</h2>
                <p class="text-slate-500 mb-4">Enter a string to deconstruct. The engine works best on text with periodic, interleaved patterns.</p>
                <textarea id="input-text" class="w-full h-28 p-3 border border-slate-300 rounded-md focus:ring-2 focus:ring-teal-500 focus:outline-none mono bg-slate-50" placeholder="e.g., axbyaxcyaxdy... or abcdabcdabcd..."></textarea>
                <button id="analyze-button" class="mt-4 w-full sm:w-auto bg-slate-800 text-white font-bold py-2 px-8 rounded-md hover:bg-slate-900 transition-colors">Analyze</button>
            </div>
            
            <div id="results-area" class="hidden">
                <hr class="my-8 border-slate-200">
                <h2 class="text-2xl font-bold text-slate-700 mb-6">2. Structural Analysis</h2>
                <div class="grid grid-cols-1 xl:grid-cols-5 gap-8">
                    <!-- Left column: Visualization -->
                    <div class="xl:col-span-3">
                        <h3 class="text-xl font-semibold text-slate-600 mb-3">Projection Visualization</h3>
                         <p class="text-slate-500 mb-4">This is the original string, color-coded by its identified resonances. Hover over an entry in the "Resonance Key" to highlight its projection here. Uncolored characters form the Remnant Stream.</p>
                        <div class="bg-slate-50 p-2 rounded-md border border-slate-200">
                           <canvas id="visualization-canvas"></canvas>
                        </div>
                    </div>
                    <!-- Right column: Data Blueprint -->
                    <div class="xl:col-span-2">
                        <h3 class="text-xl font-semibold text-slate-600 mb-3">The Blueprint</h3>
                        <div class="space-y-6">
                            <!-- Stats -->
                            <div class="grid grid-cols-3 gap-4 text-center">
                                <div>
                                    <p class="text-sm text-slate-500">Original</p>
                                    <p id="original-length" class="text-2xl font-bold mono text-slate-700">-</p>
                                </div>
                                <div>
                                    <p class="text-sm text-slate-500">Encoded</p>
                                    <p id="final-length" class="text-2xl font-bold mono text-slate-700">-</p>
                                </div>
                                <div>
                                    <p class="text-sm text-slate-500">Reduction</p>
                                    <p id="ratio" class="text-2xl font-bold mono text-teal-600">-</p>
                                </div>
                            </div>
                            <!-- Resonance Key -->
                            <div>
                                <h4 class="font-semibold text-slate-600 mb-2">Resonance Key</h4>
                                <div id="key-output" class="text-sm mono space-y-1 max-h-40 overflow-y-auto pr-2 border border-slate-200 rounded-md p-3 bg-slate-50">
                                    <p class="text-slate-500">No resonances identified.</p>
                                </div>
                            </div>
                            <!-- Remnant Stream -->
                            <div>
                                <h4 class="font-semibold text-slate-600 mb-2">Remnant Stream</h4>
                                <div id="remnant-output" class="p-3 bg-slate-50 border border-slate-200 rounded-md text-sm mono break-all max-h-24 overflow-y-auto">
                                    <p class="text-slate-500">N/A</p>
                                </div>
                            </div>
                             <!-- Reconstitution -->
                            <div>
                                <h4 class="font-semibold text-slate-600 mb-2">Reconstitution Check</h4>
                                <button id="reconstitute-button" class="w-full bg-white border border-slate-300 text-slate-700 font-bold py-2 px-4 rounded-md hover:bg-slate-50 transition-colors">Reconstitute & Verify</button>
                                <div id="reconstitution-output" class="mt-2 p-2 bg-slate-100 border border-slate-200 rounded-md text-xs mono break-all text-slate-500 hidden"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const inputEl = document.getElementById('input-text');
            const analyzeBtn = document.getElementById('analyze-button');
            const reconstituteBtn = document.getElementById('reconstitute-button');
            const canvas = document.getElementById('visualization-canvas');
            const ctx = canvas.getContext('2d');

            const resultsArea = document.getElementById('results-area');
            const originalLengthEl = document.getElementById('original-length');
            const finalLengthEl = document.getElementById('final-length');
            const ratioEl = document.getElementById('ratio');
            const keyEl = document.getElementById('key-output');
            const remnantEl = document.getElementById('remnant-output');
            const reconstitutionEl = document.getElementById('reconstitution-output');

            let analysisResult = null;
            let hoveredKeyIndex = -1;
            
            const PALETTE = ['#0d9488', '#d97706', '#be185d', '#65a30d', '#57534e', '#8b5cf6']; // Teal, Amber, Pink, Lime, Stone, Violet

            const analyze = () => {
                const text = inputEl.value;
                if (!text) return;

                // 1. Full-Spectrum Resonance Scan
                let resonances = [];
                for (let stride = 1; stride <= text.length / 2; stride++) {
                    for (let offset = 0; offset < stride; offset++) {
                        if (offset + stride >= text.length) continue;
                        
                        let i = offset;
                        while(i < text.length) {
                             const char = text[i];
                             let count = 1;
                             let currentPos = i + stride;
                             while (currentPos < text.length && text[currentPos] === char) {
                                 count++;
                                 currentPos += stride;
                             }

                             if (count > 1) {
                                 const keyDesc = `(${char},${stride},${count},${i})`;
                                 const savings = (count) - keyDesc.length;
                                 if (savings > 0) {
                                     resonances.push({ char, stride, count, offset: i, savings, desc: keyDesc });
                                 }
                                 i += (count * stride);
                             } else {
                                i += stride;
                             }
                        }
                    }
                }
                
                // 2. Optimal Resonance Selection (Greedy)
                resonances.sort((a, b) => b.savings - a.savings);
                const finalKey = [];
                const claimedPositions = new Array(text.length).fill(false);
                
                for (const res of resonances) {
                    let canBeClaimed = true;
                    for (let i = 0; i < res.count; i++) {
                        if (claimedPositions[res.offset + i * res.stride]) {
                            canBeClaimed = false;
                            break;
                        }
                    }
                    if (canBeClaimed) {
                        finalKey.push(res);
                        for (let i = 0; i < res.count; i++) {
                            claimedPositions[res.offset + i * res.stride] = true;
                        }
                    }
                }

                // 3. Key and Remnant Generation
                let remnant = '';
                for (let i = 0; i < text.length; i++) {
                    if (!claimedPositions[i]) {
                        remnant += text[i];
                    }
                }
                
                analysisResult = { originalText: text, key: finalKey.sort((a,b) => a.offset - b.offset), remnant };
                resultsArea.classList.remove('hidden');
                updateUI();
                drawVisualization();
            };

            const drawVisualization = () => {
                if (!analysisResult) return;
                const { originalText, key } = analysisResult;
                
                const dpr = window.devicePixelRatio || 1;
                const parentWidth = canvas.parentElement.clientWidth;
                canvas.width = parentWidth * dpr;
                
                const charSize = Math.min(24, parentWidth / 30);
                const charsPerRow = Math.floor(parentWidth / charSize);
                const numRows = Math.ceil(originalText.length / charsPerRow);
                const canvasHeight = numRows * charSize * 1.5;
                canvas.height = canvasHeight * dpr;

                ctx.scale(dpr, dpr);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.font = `500 ${charSize * 0.8}px 'Roboto Mono'`;
                
                const claimed = new Array(originalText.length).fill(-1);
                key.forEach((res, keyIndex) => {
                    for (let i = 0; i < res.count; i++) {
                        claimed[res.offset + i * res.stride] = keyIndex;
                    }
                });

                for(let i = 0; i < originalText.length; i++) {
                    const row = Math.floor(i / charsPerRow);
                    const col = i % charsPerRow;
                    const x = col * charSize + (charSize / 2);
                    const y = row * charSize * 1.5 + (charSize / 2);
                    const keyIndex = claimed[i];
                    
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    if (keyIndex !== -1) {
                         const color = PALETTE[keyIndex % PALETTE.length];
                         ctx.fillStyle = color;
                         if (keyIndex === hoveredKeyIndex) {
                            ctx.fillStyle = '#000';
                            ctx.fillRect(x - charSize/2, y - charSize/2, charSize, charSize);
                            ctx.fillStyle = '#fff';
                         }
                    } else {
                        ctx.fillStyle = '#94a3b8'; // slate 400
                    }
                    
                    ctx.fillText(originalText[i], x, y);
                }
            };
            
            const updateUI = () => {
                const { originalText, key, remnant } = analysisResult;
                const keyLength = key.reduce((acc, k) => acc + k.desc.length, 0);
                const finalLength = keyLength + remnant.length;
                const ratio = originalText.length > 0 ? (100 * (1 - finalLength / originalText.length)).toFixed(1) : 0;

                originalLengthEl.textContent = originalText.length;
                finalLengthEl.textContent = finalLength;
                ratioEl.textContent = `${ratio > 0 ? ratio : 0}%`;

                if (key.length > 0) {
                    keyEl.innerHTML = '';
                    key.forEach((res, index) => {
                        const entry = document.createElement('div');
                        entry.className = 'key-entry p-1 rounded transition-colors';
                        entry.dataset.keyIndex = index;
                        const color = PALETTE[index % PALETTE.length];
                        entry.innerHTML = `<span class="inline-block w-3 h-3 rounded-full mr-2" style="background-color: ${color};"></span><span>${res.desc}</span>`;
                        entry.onmouseenter = () => { hoveredKeyIndex = index; drawVisualization(); };
                        entry.onmouseleave = () => { hoveredKeyIndex = -1; drawVisualization(); };
                        keyEl.appendChild(entry);
                    });
                } else {
                    keyEl.innerHTML = '<p class="text-slate-500">No resonances identified.</p>';
                }
                
                remnantEl.textContent = remnant || 'N/A';
                reconstitutionEl.classList.add('hidden');
            };

            const reconstitute = () => {
                if (!analysisResult) return;
                const { originalText, key, remnant } = analysisResult;
                
                let buffer = new Array(originalText.length).fill(null);
                
                key.forEach(res => {
                    for(let i=0; i < res.count; i++) {
                        buffer[res.offset + i * res.stride] = res.char;
                    }
                });
                
                let remnantIndex = 0;
                for(let i=0; i < buffer.length; i++) {
                    if (buffer[i] === null) {
                        buffer[i] = remnant[remnantIndex++];
                    }
                }
                
                const reconstitutedText = buffer.join('');
                const isLossless = reconstitutedText === originalText;
                
                reconstitutionEl.textContent = `Verification: ${isLossless ? 'Perfect Match!' : 'Mismatch Detected.'}\n\n${reconstitutedText}`;
                reconstitutionEl.classList.remove('hidden');
                reconstitutionEl.classList.toggle('text-green-700', isLossless);
                reconstitutionEl.classList.toggle('bg-green-100', isLossless);
                reconstitutionEl.classList.toggle('border-green-200', isLossless);
                reconstitutionEl.classList.toggle('text-red-700', !isLossless);
                reconstitutionEl.classList.toggle('bg-red-100', !isLossless);
                reconstitutionEl.classList.toggle('border-red-200', !isLossless);

            }
            
            analyzeBtn.addEventListener('click', analyze);
            reconstituteBtn.addEventListener('click', reconstitute);
            window.addEventListener('resize', () => {
                if(analysisResult) drawVisualization();
            });
            
            inputEl.value = "abcdeabcdeabcdeabcdeabcdePAPAPAPAPAzzyyzzxxyyzz";
            analyze();
        });
    </script>
</body>
</html>
